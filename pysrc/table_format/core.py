#!/usr/bin/env python3
"""
Core TableFormatter class for the table_format package.

Generated by AI: GitHub Copilot
Date: November 5, 2025
Purpose: Core table formatting functionality with TableFormatter class
"""

import json
from typing import Any, Dict, List, Tuple, Union, Callable, Optional


class TableFormatter:
    """
    A flexible table formatter class that can format various data structures
    into text-based tables with customizable columns and formatting.
    """

    def __init__(self, border_style='ascii', truncation_mode='right', max_autosize_width=50):
        """
        Initialize TableFormatter with specified formatting options.

        Args:
            border_style (str): Border style ('ascii', 'minimal')
            truncation_mode (str): Text truncation behavior ('right', 'left')
            max_autosize_width (int): Maximum width for autosize columns (default: 50)
        """
        self.border_style = border_style
        self.truncation_mode = truncation_mode
        self.max_autosize_width = max_autosize_width
        self._set_border_chars()

    def _set_border_chars(self):
        """Set border characters based on style."""
        if self.border_style == 'minimal':
            self.corner = ' '
            self.horizontal = '-'
            self.vertical = ' '
        else:  # ascii (default)
            self.corner = '+'
            self.horizontal = '-'
            self.vertical = '|'

    def _adjust_column_widths(self, columns: List[Tuple[str, int]]) -> List[Tuple[str, int]]:
        """
        Adjust column widths to ensure they are at least as wide as their headers.

        Args:
            columns: List of tuples (column_name, width)

        Returns:
            List of tuples with adjusted widths
        """
        adjusted_columns = []
        for header, width in columns:
            # Ensure width is at least as wide as the header text
            min_width = max(width, len(header))
            adjusted_columns.append((header, min_width))
        return adjusted_columns

    def _calculate_autosized_columns(self,
                                   data: Union[Dict[str, Any], List[Union[Dict, List]]],
                                   columns: List[Tuple[str, int]],
                                   extractor: Optional[Callable] = None) -> List[Tuple[str, int]]:
        """
        Calculate optimal column widths for autosize columns (width=0).

        Args:
            data: The data to analyze for sizing
            columns: List of tuples (column_name, width) where width=0 means autosize
            extractor: Optional function to extract row data

        Returns:
            List of tuples with calculated widths for autosize columns
        """
        calculated_columns = []

        # First, collect all row data to analyze content lengths
        all_row_data = []

        if isinstance(data, dict):
            for key, value in data.items():
                if extractor:
                    row_data = extractor(key, value, columns)
                else:
                    row_data = self._default_dict_extractor(key, value, columns)
                all_row_data.append(row_data)
        elif isinstance(data, list):
            for i, item in enumerate(data):
                if extractor:
                    row_data = extractor(i, item, columns)
                else:
                    row_data = self._default_list_extractor(i, item, columns)
                all_row_data.append(row_data)

        # Calculate optimal width for each column
        for col_idx, (header, width) in enumerate(columns):
            if width == 0:  # Autosize this column
                # Start with header width as minimum
                max_width = len(header)

                # Check all data in this column
                for row_data in all_row_data:
                    if col_idx < len(row_data):
                        content_length = len(str(row_data[col_idx]))
                        max_width = max(max_width, content_length)

                # Set reasonable limits for autosize (minimum 5, maximum from constructor)
                optimal_width = max(5, min(self.max_autosize_width, max_width))
                calculated_columns.append((header, optimal_width))
            else:
                # Keep the original width for non-autosize columns
                calculated_columns.append((header, width))

        return calculated_columns

    def format_dict_table(self,
                          data: Dict[str, Any],
                          columns: List[Tuple[str, int]],
                          extractor: Optional[Callable] = None,
                          title: str = None,
                          show_total: bool = True) -> str:
        """
        Format a dictionary as a table where each key becomes a row.

        Args:
            data (dict): Dictionary data to format
            columns (list): List of tuples (column_name, width) where width=0 means autosize
            extractor (callable, optional): Function to extract row data from each dict entry
            title (str, optional): Table title
            show_total (bool): Whether to show total count

        Returns:
            str: Formatted table as string, or empty string if error
        """
        try:
            if not data:
                return "No data to format.\n"

            # Calculate autosized columns first
            autosized_columns = self._calculate_autosized_columns(data, columns, extractor)

            # Adjust column widths to accommodate headers
            adjusted_columns = self._adjust_column_widths(autosized_columns)

            result = ""
            result += self._print_title(title)
            result += self._print_table_frame(data, adjusted_columns, extractor)

            if show_total:
                result += f"\nTotal entries: {len(data)}\n"

            return result

        except Exception as e:
            return f"Error formatting table: {e}\n"

    def format_list_table(self,
                          data: List[Union[Dict, List]],
                          columns: List[Tuple[str, int]],
                          extractor: Optional[Callable] = None,
                          title: str = None,
                          show_total: bool = True) -> str:
        """
        Format a list of dictionaries or lists as a table.

        Args:
            data (list): List of dictionaries or lists
            columns (list): List of tuples (column_name, width) where width=0 means autosize
            extractor (callable, optional): Function to extract row data from each item
            title (str, optional): Table title
            show_total (bool): Whether to show total count

        Returns:
            str: Formatted table as string, or empty string if error
        """
        try:
            if not data:
                return "No data to format.\n"

            # Calculate autosized columns first
            autosized_columns = self._calculate_autosized_columns(data, columns, extractor)

            # Adjust column widths to accommodate headers
            adjusted_columns = self._adjust_column_widths(autosized_columns)

            result = ""
            result += self._print_title(title)
            result += self._print_separator(adjusted_columns)
            result += self._print_header_row(adjusted_columns)
            result += self._print_separator(adjusted_columns)

            for i, item in enumerate(data):
                if extractor:
                    row_data = extractor(i, item, adjusted_columns)
                else:
                    row_data = self._default_list_extractor(i, item, adjusted_columns)
                result += self._print_data_row(row_data, adjusted_columns)

            result += self._print_separator(adjusted_columns)

            if show_total:
                result += f"\nTotal entries: {len(data)}\n"

            return result

        except Exception as e:
            return f"Error formatting table: {e}\n"

    def format_json_file(self,
                         json_file_path: str,
                         columns: List[Tuple[str, int]],
                         extractor: Optional[Callable] = None,
                         title: str = None) -> str:
        """
        Load and format JSON file data as a table.

        Args:
            json_file_path (str): Path to JSON file
            columns (list): List of tuples (column_name, width)
            extractor (callable, optional): Function to extract row data
            title (str, optional): Table title

        Returns:
            str: Formatted table as string, or error message if failed
        """
        try:
            with open(json_file_path, 'r') as f:
                data = json.load(f)

            if isinstance(data, dict):
                return self.format_dict_table(data, columns, extractor, title)
            elif isinstance(data, list):
                return self.format_list_table(data, columns, extractor, title)
            else:
                return f"Unsupported data type: {type(data)}\n"

        except FileNotFoundError:
            return f"Error: File '{json_file_path}' not found.\n"
        except json.JSONDecodeError as e:
            return f"Error: Invalid JSON format: {e}\n"
        except Exception as e:
            return f"Error: {e}\n"

    def _print_table_frame(self, data, columns, extractor):
        """Generate the complete table frame for dictionary data."""
        result = ""
        result += self._print_separator(columns)
        result += self._print_header_row(columns)
        result += self._print_separator(columns)

        for key, value in data.items():
            if extractor:
                row_data = extractor(key, value, columns)
            else:
                row_data = self._default_dict_extractor(key, value, columns)
            result += self._print_data_row(row_data, columns)

        result += self._print_separator(columns)
        return result

    def _default_dict_extractor(self, key, value, columns):
        """Default extractor for dictionary data."""
        row_data = []
        for col_name, _ in columns:
            col_lower = col_name.lower()
            if col_lower in ['key', 'name', 'id']:
                row_data.append(str(key))
            elif col_lower in ['value', 'count'] and not isinstance(value, dict):
                row_data.append(str(value))
            elif isinstance(value, dict):
                # Try exact match first, then case-insensitive
                if col_name in value:
                    row_data.append(str(value[col_name]))
                else:
                    # Try case-insensitive match
                    found = False
                    for k, v in value.items():
                        if k.lower() == col_lower:
                            row_data.append(str(v))
                            found = True
                            break
                    if not found:
                        row_data.append('')
            else:
                row_data.append('')
        return row_data

    def _default_list_extractor(self, index, item, columns):
        """Default extractor for list data."""
        row_data = []
        for i, (col_name, _) in enumerate(columns):
            col_lower = col_name.lower()
            if col_lower in ['index', '#', 'id', 'row']:
                row_data.append(str(index))
            elif isinstance(item, dict):
                # Try exact match first, then case-insensitive
                if col_name in item:
                    row_data.append(str(item[col_name]))
                else:
                    # Try case-insensitive match
                    found = False
                    for k, v in item.items():
                        if k.lower() == col_lower:
                            row_data.append(str(v))
                            found = True
                            break
                    if not found:
                        row_data.append('')
            elif isinstance(item, (list, tuple)) and i < len(item):
                row_data.append(str(item[i]))
            else:
                row_data.append('')
        return row_data

    def _print_title(self, title):
        """Generate table title string."""
        if title:
            return f"\n{title}\n" + "=" * len(title) + "\n"
        return ""

    def _print_separator(self, columns):
        """Generate a separator line for the table."""
        separator = self.corner
        for _, width in columns:
            separator += self.horizontal * (width + 2) + self.corner
        return separator + "\n"

    def _print_header_row(self, columns):
        """Generate the header row of the table."""
        row = self.vertical
        for header, width in columns:
            row += f" {header:<{width}} {self.vertical}"
        return row + "\n"

    def _print_data_row(self, row_data, columns):
        """Generate a data row of the table."""
        row = self.vertical
        for i, (_, width) in enumerate(columns):
            data = row_data[i] if i < len(row_data) else ""
            data = str(data)  # Ensure string conversion
            if len(data) > width:
                if width <= 3:
                    # If width is too small for meaningful truncation, just use ellipsis
                    data = "..." if width >= 3 else data[:width]
                elif self.truncation_mode == 'left':
                    # Left-aligned truncation (ellipsis at end)
                    data = data[:width-3] + "..."
                else:
                    # Right-aligned truncation (ellipsis at beginning) - default
                    data = "..." + data[-(width-3):]
            row += f" {data:<{width}} {self.vertical}"
        return row + "\n"