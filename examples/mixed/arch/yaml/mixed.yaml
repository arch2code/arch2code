# This example which is being used for requirements building shows 8 dictionaries
#                                                                     constants
#                                                                     variables
#                                                                     structures
#                                                                     interfaces
#                                                                     objects
#                                                                     connections
#                                                                     instances
#                                                                     flows
include:
  - mixedInclude.yaml
  - mixedBlockC.yaml
blockDir: .
enums:
  test1EnumT:
    desc: a test enum
    enum:
      - {enumName: TEST1_A, desc: Test A, value: 0}
      - {enumName: TEST1_B, desc: Test B, value: 1}
      - {enumName: TEST1_C, desc: Test C, value: 2}

# constants / parameters are architectural level variables that can be used to control the size of structures,
# variables, number of instances, etc.
## constantname: is the constant's name and key for usage by any other dictionary doing a lookup, required
## for any other key in any other dictionary
### value: followed by a number to indicate the value for this constant, required if eval is not used
### desc: followed by a string is a description of this constant, required
### eval: optional in place of value, this is a math function that can be used to make a constant from other constant
###       supports +, -, *, and / math.
### to reference another constant use $CONSTNAME
constants:
  ASIZE : {value: 1, desc: "The size of A"}
  ASIZE2: {eval: "$ASIZE+1", desc: "The size of A+1"}
  INTP: {value: 0xFFFFFC00, desc: "Test constant for numbers of unsigned integer type "}
  INTN: {value: -0x7FFFFC00, desc: "Test constant for numbers of signed integer type (two's complement negative)"}
  LONGP: {value: 0x1FFFFFFFFFFFFC00, desc: "Test constant for numbers unsigned long type "}
  LONGN: {value: -0xFFFFFC00, desc: "Test constant for numbers signed long type (two's complement negative)"}
  BIGE33: {value: 0x1FFFFFFFF, desc: "Test constant for numbers slightly bigger than 32 bits"}
  BIGE53: {value: 0x3FFFFFFFFFFFFF, desc: "Test constant for numbers slightly bigger than 32 bits"}
# Test constant for https://arch2code.atlassian.net/browse/A2C-89
 #YUGE  : {value: 0xFFFFFFFFFFFFFFFF, desc: "Test constant for numbers of 64 bits"}
  YUGE  : {value: 0x7FFFFFFFFFFFFFFF, desc: "Test constant for numbers of 63 bits"}
  DWORD : {value: 32, desc: size of a double word}
  DWORD_LOG2 : {eval: "($DWORD).bit_length()", desc: "size of a double word log2"}
  BOB0  : {value: 16, desc: "Memory size for instance 0"}
  BOB1  : {value: 15, desc: "Memory size for instance 1"}
  TESTCONST1 : {value: 1, desc: "A test constant"}
  TESTCONST2 : {eval: "$TEST1_C+4", desc: "A test constant using an enum value"}

encoders:
  opcodeEnA:
    desc: "Opcode Encoder A"
    encoderType: opcodeTagT
    encoderTypeDesc: opcode tag
    encoderTypeWidth: 9
    enumType: opcodeEnumT
    enumPrefix: OPCODEATYPE_
    baseConstPrefix: OPCODEABASE_
    zeroBased: true
    items:
      read:     { numBits: DWORD_LOG2,     desc: Read command,   varName: read }
      write:    { numBits: DWORD_LOG2,     desc: Write command,  varName: write }
      wait:     { numBits: DWORD_LOG2,     desc: Wait command,   varName: wait }
      evict:    { numBits: DWORD_LOG2,     desc: Evict command,  varName: evict }
      trim:     { numBits: 1,              desc: Trim command,   varName: trim }


types:
  testEnumT:
    desc: a test enum
    enum:
      - {enumName: TEST_A, desc: Test A, value: 0}
      - {enumName: TEST_B, desc: Test B, eval: $TESTCONST1+4}
      - {enumName: TEST_C, desc: Test C, value: 2}
  twoBitT:
    width: 2
    desc: this is a 2 bit type
  threeBitT:
    width: 3
    desc: this is a 3 bit type
  fourBitT:
    width: 4
    desc: this is a 4 bit type
  sevenBitT:
    width: 7
    desc: Used as a threeBitT plus a fourBitT for the register structure dRegSt
  aSizeT:
    width: ASIZE
    desc: type of width ASIZE
  aBiggerT:
    width: ASIZE2
    desc: yet another type
  bSizeT:
    width: BSIZE_LOG2
    desc: for addressing memory
  wordT:
    width: 16
    desc: a word type, used for test
  readyT:
    desc: either ready or not ready
    enum:
      - {enumName: READY_NO,  desc: Not ready, value: 0}
      - {enumName: READY_YES, desc: Ready,     value: 1}
  opcodeT:
    desc: opcode with fixed width
    width: 8
    enum:
      - {enumName: ADD,     desc: Add,      value: 0}
      - {enumName: SUB,     desc: Subtract, value: 5}
  apbAddrT:
    width: DWORD
    desc: for addressing register via APB
  apbDataT:
    width: DWORD
    desc: for the data sent or recieved via APB
  signedByte_t:
    width: 8
    isSigned: true
    desc: "Signed 8-bit type (-128 to 127)"
  signedWord_t:
    width: 16
    isSigned: true
    desc: "Signed 16-bit type (-32768 to 32767)"
  signedDword_t:
    width: 32
    isSigned: true
    desc: "Signed 32-bit type"
  signedNibble_t:
    width: 4
    isSigned: true
    desc: "Signed 4-bit type (-8 to 7) for testing small signed values"
  signed3bit_t:
    width: 3
    isSigned: true
    desc: "Signed 3-bit type (-4 to 3) non-byte-aligned"
  signed5bit_t:
    width: 5
    isSigned: true
    desc: "Signed 5-bit type (-16 to 15) non-byte-aligned"
  signed7bit_t:
    width: 7
    isSigned: true
    desc: "Signed 7-bit type (-64 to 63) non-byte-aligned"
  signed11bit_t:
    width: 11
    isSigned: true
    desc: "Signed 11-bit type (-1024 to 1023) non-byte-aligned"
  unsigned5bit_t:
    width: 5
    desc: "Unsigned 5-bit type for mixed testing"
  unsigned9bit_t:
    width: 9
    desc: "Unsigned 9-bit type for mixed testing"


# variables used as members of structures, only structures are attached to interfaces
## variablename: is the variable's name and key for usage by any other dictionary doing a lookup, required
### width: followed by a number or a constant's key (constantname), required
### desc: followed by a string is a description of this variable, required
variables:
  variablea:
    type: aSizeT
    desc: One bit of A
  variablea2:
    type: aBiggerT
    desc: Two bits of A
  variabled:
    type: threeBitT
    desc: Three bits of D
  variabled2:
    type: fourBitT
    desc: Four bits of D

# structures are collections of variables, or other structures, structures are the main communication tool from block to block on any interface
## structureName: is the structure's name and key for usage by any other dictionary doing a lookup, required
### - variablename
### - strcuturename
### dash (-) followed by a variablename or a structureName, the dash is making a list of variables or structures at least one is required to create a valid structure
### if no type is specified the variable must exist in the variables section
structures:
  aSt:
    variablea: {arraySize: ASIZE2}
    variablea2: {varType: twoBitT}
  aASt:
    variablea: {}
  aRegSt:
    a: {varType: sevenBitT, generator: register}
  dRegSt:
    d: {varType: sevenBitT, generator: register}
  dSt:
    variabled: {}
    variabled2: {}
  nestedSt:
    variablea: {}
    bob: {subStruct: dSt}
    joe: {subStruct: seeSt, arraySize: 2, desc: Need two of these}
    #generator: register
# after https://arch2code.atlassian.net/browse/A2C-123
  bSizeRegSt:
    index: {varType: bSizeT, generator: register}
  bSizeSt:
    index: {varType: bSizeT}
  apbAddrSt:
    address: {varType: apbAddrT, generator: address}
  apbDataSt:
    data: {varType: apbDataT, generator: data}
  cSt:
    sevenBitArray: {varType: sevenBitT, arraySize: 5, desc: "An array of total size > 32 bit and < 64 bits"}
  test1St:
    sevenBitArray: {varType: sevenBitT, arraySize: 5, desc: "An array of total size > 32 bit and < 64 bits"}
    sevenBitArray2: {varType: sevenBitT, arraySize: 5, desc: "An array of total size > 32 bit and < 64 bits"}
  test2St:
    thirtyFiveBitArray: {subStruct: cSt, arraySize: 5, desc: "An array of 35 bit * 5"}
  test3St:
    sevenBitArray: {subStruct: aRegSt, arraySize: 5, desc: "An array of 7 bit * 5"}
  test4St:
    sevenBitArray: {subStruct: aRegSt, desc: "An array of 7 bit"}
  test5St:
    sevenBitArray: {subStruct: aRegSt, arraySize: 10, desc: "An array of 7 bit * 10"}
  test6St:
    largeStruct: {subStruct: test1St, desc: "An array of 70 bit"}
  test7St:
    largeStruct: {subStruct: test1St, arraySize: 5, desc: "An array of 70 bit * 5"}
  test8St:
    words: {varType: wordT, arraySize: 3, desc: "Aligned array of 3 words, each word is 16 bits"}
  test9St:
    wordArray: {subStruct: test8St, arraySize: 4, desc: "Array of 4 * 48 bits"}
  signedTestSt:
    signedValue: {varType: signedByte_t, desc: "A signed byte value for testing"}
    unsignedValue: {varType: twoBitT, desc: "An unsigned two-bit value"}
  mixedSignedSt:
    temp: {varType: signedWord_t, desc: "Temperature sensor value"}
    offset: {varType: signedByte_t, desc: "Calibration offset"}
    flags: {varType: fourBitT, desc: "Status flags"}
  signedArraySt:
    values: {varType: signedNibble_t, arraySize: 3, desc: "Array of three signed nibbles"}
  nonByteAlignedSignedSt:
    field1: {varType: signed3bit_t, desc: "3-bit signed at bit 0-2"}
    field2: {varType: unsigned5bit_t, desc: "5-bit unsigned at bit 3-7"}
    field3: {varType: signed5bit_t, desc: "5-bit signed at bit 8-12"}
    field4: {varType: threeBitT, desc: "3-bit unsigned at bit 13-15"}
  complexMixedSt:
    signedA: {varType: signed7bit_t, desc: "7-bit signed field"}
    unsignedB: {varType: unsigned9bit_t, desc: "9-bit unsigned field"}
    signedC: {varType: signed11bit_t, desc: "11-bit signed field"}
    unsignedD: {varType: fourBitT, desc: "4-bit unsigned field"}
    signedE: {varType: signedByte_t, desc: "8-bit signed field to cross 32-bit boundary"}
  edgeCaseSignedSt:
    tiny: {varType: signed3bit_t, desc: "Very small signed value"}
    smallVal: {varType: signedNibble_t, desc: "Small signed value"}
    mediumVal: {varType: signed11bit_t, desc: "Medium signed value"}
    largeVal: {varType: signedWord_t, desc: "Large signed value"}
  mixedArraySignedSt:
    signedVals: {varType: signed5bit_t, arraySize: 4, desc: "Array of 4 non-byte-aligned signed values"}
    unsignedVals: {varType: unsigned5bit_t, arraySize: 3, desc: "Array of 3 non-byte-aligned unsigned values"}

# interfaces are needed to make any connection from one instance of a block to another block's instance
## interfacename: is the interface's name and key for usage by any other dictionary doing a lookup, required
### interfaceType: followed by a string that links to a valid interface type
####        i.e. rdy_vld could be defined as a ready valid interface
####             staticIf could be defined as a single port interface with a structure and no protocol
####             req_ack could be defined as a request acknowledge interface with a structure in both directions
####             req_ack
### structures: is a list of dictionaries, each dictionary has two keys, each item in the list is one per structure on this interface
###                 some interfaces can have more than one structure but all interfaces must have at least one
#### dash (-) followed by a dictionary
#### structureName: followed by a string is a key reference to the structures dictionary
#### structureType: followed by a string, the structureType is what the structureName gets bound to during generation
####                    a System Verilog interface may have more than one structureType defined and that is what each
####                    structureName gets bound to during generation, similar for System C
### desc: followed by a string is a description of this interface, required
interfaces:
  dupIf:
    desc: "Duplicate interface def"
    interfaceType: rdy_vld
    structures:
      - {structure: seeSt, structureType: data_t}
  aStuffIf:
    interfaceType: req_ack
    desc: "An interface for A"
    structures:
      - {structure: aSt, structureType: data_t}
      - {structure: aASt, structureType: rdata_t}
  dStuffIf:
    desc: "An interface for D"
    interfaceType: rdy_vld
    structures:
      - {structure: dSt, structureType: data_t}
  apbReg:
    desc: "CPU access to SoC registers in the design"
    interfaceType: apb
    structures:
      - {structure: apbAddrSt, structureType: addr_t}
      - {structure: apbDataSt, structureType: data_t}
  startDone:
    desc: "A start done interface"
    interfaceType: notify_ack

# blocks these are subsystems or blocks that can be instanced one or more times
## blockname: followed by a name that gives this object (block) a unique key
### portname: followed by a name that gives this port a unique key for this block, this is used when a block is instanced
###           more than once or if a port is instanced more than once to connect to multiple blocks with the same interface, optional
#### count: number that indicates how many of these portname exist and can be connected, optional
####          numbered from 0 upto count - 1
blocks:
  mixed:
    desc: The top most block
    hasVl: true
    hasMdl: true
    hasTb: true
  mixed_tb:
    desc: Testbench container for mixed
    hasVl: false
    hasMdl: false
    hasTb: false
    hasRtl: false
  cpu:
    desc: A RISC-V CPU
    hasVl: false
    hasMdl: true
    hasTb: false
  blockA:
    desc: The block named A
    hasVl: true
    hasMdl: true
    hasTb: false
  blockB:
    desc: The block named B
    hasVl: false
    hasMdl: true
    hasTb: false
  apbDecode:
    desc: The block to decode apb addresses
    hasVl: false
    hasMdl: true
    hasTb: false
  blockD:
    desc: The block named D
    hasVl: false
    hasMdl: true
    hasTb: false
  blockE: # Unused block - this is to test that unused blocks are handled properly by generator
    desc: The block named E
    hasMdl: false
    hasRtl: false
    hasVl: false
  blockF:
    desc: The block named F
    params: [bob, fred]
    hasVl: true
    hasMdl: true
    hasTb: false
  threeCs:
    desc: A block that contains three copies of blockC
    hasVl: false
    hasMdl: true
    hasTb: false


# instances, these are instantiations of objects
#   implies a top level of some kind that is instancing objects, an instance can instance other objects, optional nesting
## instancename: is the instance name being instanced, required
### instanceType: followed by a string which is the key to finding which object is being instanced (objectname), required
### color: followed by a string which is a color (provide link to valid colors) this adds a color to diagrams
###          for this instance, optional (currently does not work in diagram generation code)
# The highest level container must match topContainer defined in project file
instances:
  mixed_tb:
    container: mixed_tb # self reference
    instanceType: mixed_tb
    instGroup: top
  u_mixed:     {container: mixed_tb, instanceType: mixed,                          instGroup: top}
  uCPU:        {container: mixed_tb, instanceType: cpu,                            instGroup: top,                             color: pink}
  uBlockA:     {container: mixed,    instanceType: blockA,     addressGroup: top,  instGroup: top}
  uAPBDecode:  {container: mixed,    instanceType: apbDecode,                      instGroup: top,                             color: pink}
  uBlockC:     {container: mixed,    instanceType: blockC,                         instGroup: top,                             color: orange}
  uBlockB:     {container: mixed,    instanceType: blockB,     addressGroup: top,  instGroup: top,                             color: lightslateblue}
  uBlockD:     {container: blockB,   instanceType: blockD,     addressGroup: ip1,  instGroup: top, addressMultiples: 2 } #get 2x the number of addresses
  uBlockF0:    {container: blockB,   instanceType: blockF,     addressGroup: ip1,  instGroup: top, variant: variant0   }
  uBlockF1:    {container: blockB,   instanceType: blockF,                         instGroup: top, variant: variant1   }
  uThreeCs:    {container: blockB,   instanceType: threeCs,                        instGroup: top,                             color: green}
  uBlockC0:    {container: threeCs,  instanceType: blockC,                         instGroup: top,                             color: orange}
  uBlockC1:    {container: threeCs,  instanceType: blockC,                         instGroup: top,                             color: orange}
  uBlockC2:    {container: threeCs,  instanceType: blockC,                         instGroup: top,                             color: orange}

# connections are specify interface connections between different instaces of objects
## - {}, dash followed by a dictionary, connections is a list of dictionaries
### interface: followed by string that is a key to this interface, an interface can be connected 1 or more times
### src: followed by a name of the source / master instance for this conneciton
### dst: followed by a name of the destination / slave instance for this conneciton
###
### ports are optional, and are implied in most use cases. The exception is where disambiguation is needed, mainly in array use cases
### srcport: used if there is more than one objectname instance of the source / master, declares the port of source objectname to connect to
### dstport: used if there is more than one objectname instance of destination / slave, declares the port of destination objectname to connect to
### color: followed by a string which is a color (provide link to valid colors) this adds a color to diagrams
###          for this connection, optional (currently does not work in diagram generation code)
connections:
  - {interface: aStuffIf, src: uBlockA,                  dst: uBlockB,    dstport: btod} # struct defined as part of class / instance
  - {interface: cStuffIf, src: uBlockA,                  dst: uBlockC,    dstport: see}
  - {interface: cStuffIf, src: uBlockD,                  dst: uThreeCs,   dstport: see0}
  - {interface: cStuffIf, src: uBlockF0,                 dst: uThreeCs,   dstport: see1, interfaceName: cStuff1}
  - {interface: cStuffIf, src: uBlockF1,                 dst: uThreeCs,   dstport: see2, interfaceName: cStuff2}
  - {interface: dStuffIf, src: uBlockD, srcport: dee0,   dst: uBlockF0,   interfaceName: dee0}
  - {interface: dStuffIf, src: uBlockD, srcport: dee1,   dst: uBlockF1,   interfaceName: dee1}
  - {interface: dStuffIf, src: uBlockD, srcport: outD,   dst: uBlockF0,   dstport: dSin, interfaceName: loopDF} # loop interface d -> F0 -> F1 -> D
  - {interface: dStuffIf, src: uBlockF0, srcport: dSout, dst: uBlockF1,   dstport: dSin, interfaceName: loopFF}
  - {interface: dStuffIf, src: uBlockF1, srcport: dSout, dst: uBlockD,    dstport: inD,  interfaceName: loopFD}
  - {interface: apbReg,   src: uCPU,                     dst: u_mixed,    name: cpu_main}
  - {interface: startDone, src: uBlockA,                 dst: uBlockB}
  - {interface: dupIf,    src: uBlockA,                  dst: uBlockB}

# in connection maps the direction field should match the instance port direction
connectionMaps:
  - {interface: aStuffIf, block: blockB,  port: btod, direction: dst, instance: uBlockD,     instancePort: btod}
  - {interface: cStuffIf, block: threeCs, port: see0, direction: dst, instance: uBlockC0,    instancePort: see}
  - {interface: cStuffIf, block: threeCs, port: see1, direction: dst, instance: uBlockC1,    instancePort: see}
  - {interface: cStuffIf, block: threeCs, port: see2, direction: dst, instance: uBlockC2,    instancePort: see}
  - {interface: apbReg,   block: mixed,               direction: dst, instance: uAPBDecode,  name: cpu_main}

memories:
  - {memory: blockBTable0,   block: blockB, structure: seeSt, wordLines: BSIZE, addressStruct: bSizeSt, local: true, desc: "Dual Port with no connections, local mem array"}
#  - {memory: blockBTable1,   block: blockB, structure: seeSt, wordLines: BSIZE, addressStruct: bSizeSt, ports: [port1], regAccess: true, desc: "Dual Port with one connection"}
  - {memory: blockBTable2,   block: blockB, structure: seeSt, wordLines: BSIZE, addressStruct: bSizeSt, ports: [port1, port2], desc: "Dual Port with two connections native to blockB"}
  - {memory: blockBTable3,   block: blockB, structure: seeSt, wordLines: BSIZE, addressStruct: bSizeSt, ports: [read, write], desc: "Dual Port with two connections native to blockB, explicitly connected"}
  - {memory: blockBTableSP0, block: blockB, structure: seeSt, wordLines: BSIZE, addressStruct: bSizeSt, desc: "Single Port with no connections", memoryType: singlePort}
#  - {memory: blockBTableSP,  block: blockB, structure: nestedSt, wordLines: BSIZE, addressStruct: bSizeSt, ports: [bob], desc: "Single Port with connection",  memoryType: singlePort, count: ASIZE}
  - {memory: test,           block: blockF, structure: seeSt, wordLines: bob, addressStruct: bSizeSt, desc: "Dual Port with one connection"}
#  - {memory: blockBTableExt, block: blockB, structure: seeSt, wordLines: BSIZE, addressStruct: bSizeSt, regAccess: true, desc: "External memory - interfaces created, hardware not instantiated", memoryType: external}

parameters:
  blockF:
    - {variant: variant0, param: bob,  value: BOB0 }
    - {variant: variant0, param: fred, value: 0    }
    - {variant: variant1, param: bob,  value: BOB1 }
    - {variant: variant1, param: fred, value: 1    }

#memoryConnections:
#  - {memory: blockBTable1,  block: blockB, instance: uBlockD, port: port1}
#  - {memory: blockBTableSP, block: blockB, instance: uBlockD, port: bob}

registers:
# after https://arch2code.atlassian.net/browse/A2C-123
#  uncommnet rwNestsed and roD once fixed, this works for SystemVerilog but no SystemC currently
# - {register: rwNested, regType: rw,  block: blockB,   structure: nestedSt,   desc: A Read Write register with a nested structure}
  - {register: rwD,      regType: rw,  block: blockB,   structure: dRegSt,     desc: A Read Write register}
#  - {register: extD,     regType: ext, block: blockB,   structure: dRegSt,     desc: An External register}
  - {register: roBsize,  regType: ro,  block: blockB,   structure: bSizeRegSt, desc: A Read Only register with a structure that has a definition from an included context}
  - {register: roA,      regType: ro,  block: blockA,   structure: aRegSt,     desc: A Read Only register}
#  - {register: extA,     regType: ext, block: blockA,   structure: aRegSt,     desc: An External register}

registerConnections:
  - {register: rwD,     block: blockB, instance: uBlockF0 }
  - {register: rwD,     block: blockB, instance: uBlockF1 }
  - {register: rwD,     block: blockB, instance: uBlockD }
  - {register: roBsize, block: blockB, instance: uBlockD }
#  - {register: extD,    block: blockB, instance: uBlockD }

# flows, are very similar to a plantuml sequence diagram, a filename is taken and optionally
#   consistency checks can be made for connections the flow
## filenames:
### - , dash followed by a string indicates the filename for each flow
####    inside each flow a connection can be indicated and checked for consistency
####    the format for consistency check and connection replacement in a flow must follow the below format
####    instance operator instance : connectionKey '''process'''
####    For example
####    blockA -> blockC : cs_stuff '''process'''
#####     spaces are recuired between each item in the string, the word proccess inside triple ticks
#####     is also needed without spaces to aid in processing
flows:
  filenames:
    - pu_input/is_data_still_valid.pu # this example flow contains an example of a processed connection
    - pu_input/from_plantuml.pu
