// copyright the arch2code project contributors, see https://bitbucket.org/arch2code/arch2code/src/main/LICENSE
#ifndef AXI_READ_CHANNEL_H
#define AXI_READ_CHANNEL_H

#include "sysc/kernel/sc_dynamic_processes.h"
#include "sysc/communication/sc_communication_ids.h"
#include "sysc/communication/sc_prim_channel.h"
#include "rdy_vld_channel.h"
#include "sysc/kernel/sc_event.h"
#include "sysc/kernel/sc_simcontext.h"
#include "sysc/tracing/sc_trace.h"
#include <typeinfo>
#include <iostream>
#include "portBase.h"
#include "interfaceBase.h"
#include "pingPongBuffer.h"
#include <memory>
#include <vector>
#include "simpleQueue.h"
#include <fmt/format.h>
#include "axiCommon.h"

// sendAddr( A )
//          -------> receiveAddr( &A )
//          <------- sendData( D )
// receiveData( &D )

template <typename D>
struct axiReadRespSt
{
    _axiIdT rid; // Slave Read ID tag. This signal is the identification tag for the read data group of signals generated by the slave
    D rdata;     // Slave Read data
    _axiResponseT rresp; // Slave Read response. This signal indicates the status of the read transfer
    bool rlast; // Slave Read last. This signal indicates the last transfer in a read burst transaction

    axiReadRespSt() {};
    static constexpr int idWidth = 4; // number of bits in rid
    static constexpr int respWidth = 2; // number of bits in rresp
    static constexpr int dataWidth = D::_bitWidth; // number of bits in rlast

    static int getBurstSize(void) { return(sizeof(D));} // returns datapath width in bytes

    inline D * getDataPtr(void) {return &rdata;} // returns pointer to internal data element. Note this is unrelated to any backdoor

    inline bool operator == (const axiReadRespSt< D > & rhs) const {
        return (
            rhs.rid == rid &&
            rhs.rdata == rdata &&
            rhs.rresp == rresp &&
            rhs.rlast == rlast
        );
    }
    inline friend void sc_trace(sc_trace_file *tf, const axiReadRespSt< D > & v, const std::string & NAME ) {
        sc_trace(tf,v.rid, NAME + ".rid");
        sc_trace(tf,v.rdata, NAME + ".rdata");
        sc_trace(tf,v.rresp, NAME + ".rresp");
        sc_trace(tf,v.rlast, NAME + ".rlast");
    }
    inline friend ostream& operator << ( ostream& os,  axiReadRespSt< D > const & v ) {
        os << "("
           << std::hex << std::setw(1) << (int)v.rid << ", "
           << v.rdata.prt() << ", "
           << _axiResponseT_prt(v.rresp) << ", "
           << std::hex << std::setw(1) << (int)v.rlast << ");";
        return os;
    }
    std::string prt(bool all=false) const
    {
        std::stringstream ss;
        ss << "rid:0x" << std::hex << std::setw(1) << (int)rid
           << " rdata:" << rdata.prt()
           << " rresp:" << _axiResponseT_prt(rresp)
           << " rlast:0x" << std::hex << std::setw(1) << (int)rlast;
        return(ss.str());
    }
    static const char * getValueType(void)
    {
        return( D::getValueType() );
    }
    inline uint64_t getStructValue(void) const
    {
        return( rdata.getStructValue() );
    }

};

template <typename A>
struct axiReadAddressSt
{
    _axiIdT     arid;    // Master Read address ID. This signal is the identification tag for the read address group of signals (4bits)
    A           araddr;  // Master Read address. The read address gives the address of the first transfer in a read burst transaction
    uint8_t     arlen;   // Master Burst length. This signal indicates the exact number of transfers in a burst.
    _axiSizeT   arsize;  // Master Burst size. This signal indicates the size of each transfer in the burst.
    _axiBurstT  arburst; // Master Burst type. The burst type and the size information determine how the address for each transfer within the burst is calculated
    static constexpr int idWidth = 4; // number of bits in arid
    static constexpr int addrWidth = A::_bitWidth; // number of bits in araddr
    static constexpr int lenWidth = 8; // number of bits in arlen
    static constexpr int sizeWidth = 3; // number of bits in arsize
    static constexpr int burstWidth = 2; // number of bits in arburst


    axiReadAddressSt() {};

    inline bool operator == (const axiReadAddressSt< A > & rhs) const {
        return (
            rhs.arid == arid &&
            rhs.araddr == araddr &&
            rhs.arlen == arlen &&
            rhs.arsize == arsize &&
            rhs.arburst == arburst
        );
    }
    inline friend void sc_trace(sc_trace_file *tf, const axiReadAddressSt< A > & v, const std::string & NAME ) {
        sc_trace(tf,v.arid, NAME + ".arid");
        sc_trace(tf,v.araddr, NAME + ".araddr");
        sc_trace(tf,v.arlen, NAME + ".arlen");
        sc_trace(tf,v.arsize, NAME + ".arsize");
        sc_trace(tf,v.arburst, NAME + ".arburst");
    }
    inline friend ostream& operator << ( ostream& os, axiReadAddressSt< A > const & v ) {
        os << "("
           << (int)v.arid << ", "
           << v.araddr.prt() << ", "
           << (int)v.arlen << ", "
           << (int)v.arsize << ", "
           << _axiBurstT_prt(v.arburst) << ");";
        return os;
    }
    std::string prt(bool all=false) const
    {
        std::stringstream ss;
        ss << "arid:0x" << std::hex << std::setw(1) << (int)arid
           << " araddr:" << araddr.prt()
           << " arlen:0x" << std::hex << std::setw(2) << std::setfill('0') << (int)arlen
           << " arsize:0x" << std::hex << std::setw(1) << (int)arsize
           << " arburst:" << _axiBurstT_prt(arburst);
        return(ss.str());
    }
    static const char * getValueType(void)
    {
        return( A::getValueType() );
    }
    inline uint64_t getStructValue(void) const
    {
        return( araddr.getStructValue() );
    }

};

template <class A, class D>
class axi_read_in_if
: virtual public sc_interface, virtual public portBase
{
public:

    // blocking read
    virtual void receiveAddr( axiReadAddressSt<A>& ) = 0;
    virtual void sendData( const axiReadRespSt<D>& ) = 0;
    virtual void sendData( const axiReadRespSt<D>&, int burst_count ) = 0;
    virtual void sendDataCycle( const axiReadRespSt<D>& ) = 0;
    virtual uint8_t * getWritePtr(void) = 0;

protected:
    // constructor
    axi_read_in_if()
        {}

private:
    // disabled
    axi_read_in_if( const axi_read_in_if<A, D>& );
    axi_read_in_if<A, D>& operator = ( const axi_read_in_if<A, D>& );
};


template <class A, class D>
class axi_read_out_if
: virtual public sc_interface, virtual public portBase
{
public:
    // blocking write
    virtual void sendAddr( const axiReadAddressSt<A>&, std::optional<std::string> str=std::nullopt ) = 0;
    virtual void receiveData( axiReadRespSt<D>& ) = 0;
    virtual void receiveDataCycle(  axiReadRespSt<D>& ) = 0;  // for multi cycle channels, gets one burst
    virtual uint8_t * getReadPtr(void) = 0;
    virtual void push_burst(uint32_t burstCount) = 0;

protected:
    // constructor
    axi_read_out_if()
        {}

private:
    // disabled
    axi_read_out_if( const axi_read_out_if<A, D>& );
    axi_read_out_if<A, D>& operator = ( const axi_read_out_if<A, D>& );
};

class axi_read_transaction_counter {
public:
    inline static uint64_t transactionNo{0};
};

template <class A, class D>
class axi_read_channel
: public axi_read_in_if<A, D>,
  public axi_read_out_if<A, D>,
  public sc_prim_channel,
  public axi_read_transaction_counter
{
public:
    // constructor const char * module, std::string block
    explicit axi_read_channel( const char* name_, std::string block_, INTERFACE_AUTO_MODE autoMode=INTERFACE_AUTO_OFF)
      : sc_prim_channel( name_ ),
        m_addr_channel((std::string(name_) + "addr").c_str(), block_),
        m_data_channel((std::string(name_) + "data").c_str(), block_),
        m_addr_out((std::string(name_) + "addrOut").c_str()),
        m_data_out((std::string(name_) + "dataOut").c_str()),
        m_addr_in((std::string(name_) + "addrIn").c_str()),
        m_data_in((std::string(name_) + "dataIn").c_str()),
        m_reader(nullptr),
        m_writer(nullptr),
        m_transaction_pipeline(AXI_TRANSACTION_ID_MAX, simpleQueue<_axi_transaction_st>(3)),
        m_transactions(AXI_TRANSACTION_ID_MAX),
        m_active_read_transactions(AXI_TRANSACTION_ID_MAX),
        m_active_write_transactions(AXI_TRANSACTION_ID_MAX),
        m_read_cycle(AXI_TRANSACTION_ID_MAX, 0),
        m_write_cycle(AXI_TRANSACTION_ID_MAX, 0),
        m_logQueueAddr(std::make_shared<stringPingPong>()),
        m_logQueueData(std::make_shared<stringPingPong>())
        {
            m_addr_in( m_addr_channel );
            m_addr_out( m_addr_channel );
            m_data_in( m_data_channel );
            m_data_out( m_data_channel );
            m_data_channel.setLogQueue(m_logQueueData);
            m_addr_channel.setLogQueue(m_logQueueAddr);
        }

    explicit axi_read_channel( const char* name_, std::string block_, std::string multiCycleType_, int pingpong_size_, std::string trackerName_, INTERFACE_AUTO_MODE autoMode=INTERFACE_AUTO_OFF)
      : sc_prim_channel( name_ ),
        m_addr_channel((std::string(name_) + "addr").c_str(), block_),
        m_data_channel((std::string(name_) + "data").c_str(), block_, multiCycleType_, pingpong_size_ * sizeof(axiReadRespSt<D>), trackerName_),
        m_addr_out((std::string(name_) + "addrOut").c_str()),
        m_data_out((std::string(name_) + "dataOut").c_str()),
        m_addr_in((std::string(name_) + "addrIn").c_str()),
        m_data_in((std::string(name_) + "dataIn").c_str()),
        m_reader(nullptr),
        m_writer(nullptr),
        m_transaction_pipeline(AXI_TRANSACTION_ID_MAX, simpleQueue<_axi_transaction_st>(3)),
        m_transactions(AXI_TRANSACTION_ID_MAX),
        m_active_read_transactions(AXI_TRANSACTION_ID_MAX),
        m_active_write_transactions(AXI_TRANSACTION_ID_MAX),
        m_read_cycle(AXI_TRANSACTION_ID_MAX, 0),
        m_write_cycle(AXI_TRANSACTION_ID_MAX, 0),
        m_logQueueAddr(std::make_shared<stringPingPong>()),
        m_logQueueData(std::make_shared<stringPingPong>())
        {
            m_addr_in( m_addr_channel );
            m_addr_out( m_addr_channel );
            m_data_in( m_data_channel );
            m_data_out( m_data_channel );
            Q_ASSERT(multiCycleType_ =="" || multiCycleType_ == "api_list_size" || multiCycleType_ == "fixed_size", "multiCycleType must be api_list_size or fixed_size");
            m_data_channel.setLogQueue(m_logQueueData);
            m_addr_channel.setLogQueue(m_logQueueAddr);
        }

    // destructor
    virtual ~axi_read_channel() { }

    // interface methods
    virtual void register_port( sc_port_base&, const char* ) override;

    // out interfaces
    virtual void sendAddr( const axiReadAddressSt<A>&, std::optional<std::string> str ) override;
    virtual void receiveData( axiReadRespSt<D>& ) override;
    virtual void receiveDataCycle( axiReadRespSt<D>& ) override;
    virtual uint8_t * getReadPtr( void ) override;
    virtual void push_burst(uint32_t burstCount) override { m_data_in->push_context(burstCount * sizeof(axiReadRespSt<D>)); }

    // in interfaces
    virtual void receiveAddr( axiReadAddressSt<A>& ) override;
    virtual void sendData( const axiReadRespSt<D>& ) override;
    virtual void sendData( const axiReadRespSt<D>&, int burst_count ) override;
    virtual void sendDataCycle( const axiReadRespSt<D>& ) override;
    virtual uint8_t * getWritePtr(void) override;

    // other methods
    void trace( sc_trace_file* tf ) const override;

    virtual void print( ::std::ostream& = ::std::cout ) const override;
    virtual void dump( ::std::ostream& = ::std::cout ) const override;
    virtual void status(void);

    virtual const char* kind() const override
        { return "axi_read_channel"; }

    // portBase overrides
    void setMultiDriver(std::string name_, std::function<std::string(const uint64_t &value)> prt = nullptr) override
    {
        Q_ASSERT(false, fmt::format("multiple drivers on {} axiRd interface is invalid", name_ ));
    }
    std::shared_ptr<trackerBase> getTracker(void) override { return (m_data_in->getTracker());}
    virtual void setTeeBusy(bool busy) override { m_data_in->setTeeBusy(busy); }
    virtual void setTandem(void) override { m_addr_channel.setTandem(); m_data_channel.setTandem(); }
    virtual void setLogging(verbosity_e verbosity) override { m_addr_channel.setLogging(verbosity); m_data_channel.setLogging(verbosity); }
    virtual void setTimed(int nsec, timedDelayMode mode) override { m_addr_channel.setTimed(nsec, mode); m_data_channel.setTimed(nsec, mode); }
    virtual void setCycleTransaction(portType type_) override
    {
        m_cycle_transaction = true;
        m_data_out->setCycleTransaction();
        m_data_in->setCycleTransaction();
    }
protected:
    rdy_vld_channel<axiReadAddressSt<A>> m_addr_channel;
    rdy_vld_channel<axiReadRespSt<D>> m_data_channel;
public: // make these public for the tees/verif
    rdy_vld_out <axiReadAddressSt<A>> m_addr_out; // for sending address (axi_out)
    rdy_vld_out <axiReadRespSt<D>> m_data_out; // for sending data (axi_in)
    rdy_vld_in <axiReadAddressSt<A>> m_addr_in; // for receiving address (axi_in)
    rdy_vld_in <axiReadRespSt<D>> m_data_in; // for receiving data (axi_out)

protected:
    sc_port_base* m_reader; // used for static design rule checking
    sc_port_base* m_writer; // used for static design rule checking

private:
    std::vector<simpleQueue<_axi_transaction_st>> m_transaction_pipeline; // queue of transactions from response side to read side
    std::vector<std::queue<_axi_transaction_st>> m_transactions; // queue of transactions by transaction id per axi
    std::vector<_axi_transaction_st> m_active_read_transactions;
    std::vector<_axi_transaction_st> m_active_write_transactions;
    bool m_cycle_transaction = false;
    std::vector<int> m_read_cycle;
    std::vector<int> m_write_cycle;
    // disabled
    axi_read_channel( const axi_read_channel<A, D>& );
    axi_read_channel& operator = ( const axi_read_channel<A, D>& );
    std::shared_ptr<stringPingPong> m_logQueueAddr;
    std::shared_ptr<stringPingPong> m_logQueueData;
    void manageSendDataTransaction(const axiReadRespSt<D> & data_);
    void manageReceiveDataTransaction(const axiReadRespSt<D> & data_);
    void handleSendTransactionLog(_axiIdT id);
};

template <class A, class D>
inline void axi_read_channel<A, D>::register_port( sc_port_base& port_,
                const char* if_typename_ )
{
    std::string nm( if_typename_ );
    if( nm == typeid( axi_read_in_if<A, D> ).name() )
    {
        // only one reader can be connected
        if( m_reader != 0 ) {
            SC_REPORT_ERROR( SC_ID_MORE_THAN_ONE_FIFO_READER_, 0 );
            // may continue, if suppressed
        }
        m_reader = &port_;
    } else if( nm == typeid( axi_read_out_if<A, D> ).name() )
    {
        // only one writer can be connected
        if( m_writer != 0 ) {
            SC_REPORT_ERROR( SC_ID_MORE_THAN_ONE_FIFO_WRITER_, 0 );
            // may continue, if suppressed
        }
        m_writer = &port_;
    }
    else
    {
        SC_REPORT_ERROR( SC_ID_BIND_IF_TO_PORT_,
                         "axi_read_channel<A, D> port not recognized" );
        // may continue, if suppressed
    }
}

template <class A, class D>
inline void axi_read_channel<A, D>::manageSendDataTransaction(const axiReadRespSt<D> & data_)
{
    if (m_transactions[data_.rid].empty()) {
        m_data_channel.log_.logPrint(fmt::format("transaction id not valid: {}", data_.prt()));
        Q_ASSERT(false, "transaction id not valid");
    }
    m_active_write_transactions[data_.rid] = m_transactions[data_.rid].front();
    m_transactions[data_.rid].pop();
    m_transaction_pipeline[data_.rid].emplace(m_active_write_transactions[data_.rid]);
}
template <class A, class D>
inline void axi_read_channel<A, D>::manageReceiveDataTransaction(const axiReadRespSt<D> & data_)
{
    if (m_transaction_pipeline[data_.rid].isEmpty()) {
        m_data_channel.log_.logPrint(fmt::format("transaction id not valid: {}", data_.prt()));
        Q_ASSERT(false, "transaction id not valid");
    }
    m_active_read_transactions[data_.rid] = m_transaction_pipeline[data_.rid].pop();
}

template <class A, class D>
inline void axi_read_channel<A, D>::handleSendTransactionLog(_axiIdT id)
{
    if (m_data_channel.log_.isMatch(LOG_NORMAL)) {
        if (m_active_write_transactions[id].transactionStr) {
            m_logQueueData->push(*m_active_write_transactions[id].transactionStr);
        } else {
            m_logQueueData->push(fmt::format("RTX#{:x} ",m_active_write_transactions[id].transactionNo));
        }
    }
}
// blocking transactional read
template <class A, class D>
inline void axi_read_channel<A, D>::receiveAddr( axiReadAddressSt<A> &addr_ )
{
    m_addr_in->read(addr_);
}

template <class A, class D>
inline void axi_read_channel<A, D>::receiveData( axiReadRespSt<D> &data_ )
{
    Q_ASSERT(!m_cycle_transaction, "receiveData not valid api for cycle based transactions");
    m_data_in->read(data_);
    manageReceiveDataTransaction(data_);
}

// return getReadPtr based on current read buffer index
template <class A, class D>
inline uint8_t * axi_read_channel<A, D>::getReadPtr()
{
    Q_ASSERT(!m_cycle_transaction, "getReadPtr not valid api for cycle based transactions");
    return m_data_in->getReadPtr();
}

template <class A, class D>
inline uint8_t * axi_read_channel<A, D>::getWritePtr()
{
    Q_ASSERT(!m_cycle_transaction, "getWritePtr not valid api for cycle based transactions");
    return m_data_out->getWritePtr();
}


template <class A, class D>
void axi_read_channel<A, D>::receiveDataCycle(  axiReadRespSt<D> & data_)
{
    Q_ASSERT(m_cycle_transaction, "receiveDataCycle not valid api for non cycle based transactions, make sure you setCycleTransaction(PORTTYPE_IN)");
    m_data_in->readClocked(data_);
    // if first cycle perform checks
    if (m_read_cycle[data_.rid] == 0) {
        manageReceiveDataTransaction(data_);
    }
    bool last = (m_read_cycle[data_.rid] == m_active_read_transactions[data_.rid].len);
    // manage last
    if (data_.rlast != last) {
        // error case is when responder is cycle based and last is not set correctly
        Q_ASSERT(false, "last set incorrectly");
    }

    m_read_cycle[data_.rid]++;
    if (last) {
        // on last cycle reset to zero to indicate the transaction is complete
        m_read_cycle[data_.rid] = 0;
    }
}

template <class A, class D>
inline void axi_read_channel<A, D>::sendAddr( const axiReadAddressSt<A>& addr_, std::optional<std::string> str)
{
    if (m_addr_channel.log_.isMatch(LOG_NORMAL)) {
        if (str) {
            m_logQueueAddr->push(*str);
        } else {
            m_logQueueAddr->push(fmt::format("RTX#{:x} ",transactionNo));
        }
    }
    m_transactions[addr_.arid].emplace(addr_.arid, addr_.arlen, addr_.arsize, transactionNo++, std::move(str));
    m_addr_out->write(addr_);
}

template <class A, class D>
void axi_read_channel<A, D>::sendData( const axiReadRespSt<D>& data_ )
{
    Q_ASSERT(!m_cycle_transaction, "receiveData not valid api for cycle based transactions");
    manageSendDataTransaction(data_);
    handleSendTransactionLog(data_.rid);
    m_data_out->write(data_);
}
template <class A, class D>
void axi_read_channel<A, D>::sendData( const axiReadRespSt<D>& data_, int burst_count )
{
    Q_ASSERT(!m_cycle_transaction, "receiveData not valid api for cycle based transactions");
    manageSendDataTransaction(data_);
    handleSendTransactionLog(data_.rid);
    m_data_out->write(data_, burst_count * sizeof(axiReadRespSt<D>));
}


template <class A, class D>
inline void axi_read_channel<A, D>::sendDataCycle( const axiReadRespSt<D>& data_)
{
    Q_ASSERT(m_cycle_transaction, "receiveDataCycle not valid api for non cycle based transactions, make sure you setCycleTransaction(PORTTYPE_IN)");
    if (m_write_cycle[data_.rid] == 0) {
        manageSendDataTransaction(data_);
    }
    bool last = (m_write_cycle[data_.rid] == m_active_write_transactions[data_.rid].len);

    m_write_cycle[data_.rid]++;
    if (last) {
        // on last cycle reset to zero to indicate the transaction is complete
        m_write_cycle[data_.rid] = 0;
    }

    handleSendTransactionLog(data_.rid);
    m_data_out->writeClocked(data_);
}


template <class A, class D>
void axi_read_channel<A, D>::status(void)
{
    // nothing useful yet, as internal interfaces will give their own status
    //teeStatus();
}

template <class A, class D>
inline void axi_read_channel<A, D>::trace( sc_trace_file* tf ) const
{
    (void) tf; /* ignore potentially unused parameter */
}


template <class A, class D>
inline void axi_read_channel<A, D>::print( ::std::ostream& os ) const
{
    m_addr_channel.print(os);
    m_data_channel.print(os);
}

template <class A, class D>
inline void axi_read_channel<A, D>::dump( ::std::ostream& os ) const
{

}

template <class A, class D>
inline ::std::ostream& operator << ( ::std::ostream& os, const axi_read_channel<A, D>& a )
{
    a.print( os );
    return os;
}

template <class A, class D>
using axi_read_out = sc_port<axi_read_out_if<A, D> >;
template <class A, class D>
using axi_read_in = sc_port<axi_read_in_if<A, D> >;

#endif // AXI_READ_CHANNEL_H
